[//]: # ref: https://github.com/golbin/AGENTS.md/blob/main/AGENTS.ko.md

# AGENTS.md

문제 정의 → 작고 안전한 변경 → 변경 리뷰 → 리팩터링 — 이 루프를 반복한다.

## 일반적인 규칙 (General Rules)

### 필수 규칙 (Mandatory Rules)

- 무엇이든 변경하기 전에, 호출/참조 경로를 포함하여 관련 파일을 처음부터 끝까지 읽는다.
- 작업, 커밋, PR을 작게 유지한다.
- 가정을 했다면 Issue/PR/ADR에 기록한다.
- 비밀값을 커밋하거나 로그에 남기지 않는다; 모든 입력을 검증하고 출력은 인코딩/정규화한다.
- 섣부른 추상화를 피하고 의도를 드러내는 이름을 사용한다.
- 결정하기 전에 최소 두 가지 대안을 비교한다.

### 마인드셋 (Mindset)

- 시니어 엔지니어처럼 생각한다.
- 추측으로 뛰어들거나 성급히 결론내리지 않는다.
- 항상 여러 접근을 평가하고, 장점/단점/위험을 각각 한 줄로 적은 뒤 가장 단순한 해법을 선택한다.

### 코드 및 파일 참조 규칙 (Code & File Reference Rules)

- 파일은 처음부터 끝까지 철저히 읽는다(부분 읽기 금지).
- 코드를 변경하기 전에 정의, 참조, 호출 지점, 관련 테스트, 문서/설정/플래그를 찾아 읽는다.
- 파일 전체를 읽지 않았다면 코드를 변경하지 않는다.
- 심볼을 수정하기 전에 전역 검색으로 사전/사후 조건을 파악하고, 영향도를 1–3줄로 남긴다.

### 필수 코딩 규칙 (Required Coding Rules)

- 코딩 전에 Problem 1-Pager: 배경 / 문제 / 목표 / 비목표 / 제약을 작성한다.
- 제한을 준수한다: 파일 ≤ 300 LOC, 함수 ≤ 50 LOC, 매개변수 ≤ 5, 순환 복잡도 ≤ 10. 초과 시 분리/리팩터링한다.
- 명시적인 코드를 선호한다; 숨겨진 "매직" 금지.
- DRY를 따르되, 섣부른 추상화는 피한다.
- 부수효과(I/O, 네트워크, 전역 상태)는 경계층으로 격리한다.
- 구체적인 예외만 처리하고, 사용자에게 명확한 메시지를 제공한다.
- 구조화된 로깅을 사용하고 민감한 데이터를 기록하지 않는다(가능하면 요청/상관관계 ID를 전파한다).
- 시간대와 DST를 고려한다.

### 클린 코드 규칙 (Clean Code Rules)

- 의도를 드러내는 이름을 사용한다.
- 각 함수는 한 가지 일만 한다.
- 부수효과는 경계층으로 격리한다.
- 가드절을 우선 사용한다.
- 상수는 항상 심볼화한다(하드코딩 금지).
- 코드를 입력 → 처리 → 반환 구조로 구성한다.
- 실패는 구체적인 오류/메시지로 보고한다.
- 테스트는 사용 예제로도 동작하게 하고, 경계/실패 사례를 포함한다.

### 보안 규칙 (Security Rules)

- 코드/로그/티켓에 비밀값을 절대 남기지 않는다.
- 입력을 검증·정규화·인코딩하고, 파라미터화된 접근을 사용한다.
- 최소 권한 원칙을 적용한다.

### 안티 패턴 규칙 (Anti-Pattern Rules)

- 전체 문맥을 읽지 않고 코드를 수정하지 않는다.
- 비밀값을 노출하지 않는다.
- 실패나 경고를 무시하지 않는다.
- 근거 없는 최적화나 추상화를 도입하지 않는다.
- 광범위한 예외를 남용하지 않는다.

## 기술 스택별 규칙 (Technology-Specific Rules)

### TypeScript 규칙

- 타입 단언(`as`, `as any` 등)은 서비스 코드 및 테스트 코드에서 사용하지 않는다.
- 타입 안정성을 위해 TypeScript의 타입 시스템을 최대한 활용한다.
- 제네릭을 적절히 사용하여 재사용 가능한 코드를 작성한다.
- 타입 가드를 사용하여 런타임 타입 검증과 타입 좁히기를 수행한다.
- 타입 가드 내부에서만 필요한 경우 `as unknown as` 패턴을 사용할 수 있으나, 실제 사용 코드에서는 타입 단언을 사용하지 않는다.

### NestJS 규칙

- **모듈 구조**: 각 기능별로 모듈을 분리하고, `controllers`, `services`, `entities`, `dto`, `exceptions` 폴더로 구조화.
- **의존성 주입**: 생성자 주입을 사용하고, 인터페이스 기반으로 의존성을 추상화.
- **HTTP 상태 코드**: 상수로 정의하여 사용 (숫자 하드코딩 금지).
- **POST 요청**: 꼭 필요한 경우를 제외하고 HTTP 200을 반환한다 (201 Created 대신 200 OK 사용).
- **가드 사용**: 인증이 필요한 엔드포인트에는 적절한 가드를 적용.
- **ConfigService 사용**:
  - 설정값 조회 시 타입 안정성을 보장하는 메서드를 사용 (예: `getOrThrow`).
  - 타입 추론 옵션을 활용하여 타입 안정성 향상.
  - 환경 변수는 논리적으로 그룹화하여 접근 (예: `db.host`, `jwt.secret`).

### 환경 변수 관리 규칙

- **환경 변수 변환**: 환경 변수 파일의 네이밍 컨벤션을 애플리케이션 내부 네이밍 컨벤션으로 변환.
- **환경 변수 그룹화**: 관련된 환경 변수들을 논리적으로 그룹화하여 관리.
- **직접 매핑**: 자동 변환 함수보다는 명시적인 매핑을 선호하여 가독성과 유지보수성 향상.
- **타입 정의 분리**: 환경 변수 관련 타입 정의는 별도 파일로 분리하여 관리.
- **환경 변수 검증**: 환경 변수 로드 시 검증 및 변환을 수행하여 런타임 오류 방지.

### ORM 및 데이터베이스 규칙

- **ORM 설정 공유**: 애플리케이션과 마이그레이션에서 ORM 설정을 공유하여 일관성 유지.
- **마이그레이션 실행 환경**: 마이그레이션 실행 환경에서 필요한 의존성을 올바르게 로드.
- **마이그레이션 경로**: 마이그레이션은 소스 코드 기준으로 실행 (빌드된 파일 참조 금지).
- **Naming Strategy**: 일관된 네이밍 전략을 사용하여 엔티티 속성과 데이터베이스 컬럼 간 매핑.
- **BigInt 처리**: 데이터베이스의 BigInt 타입을 적절한 JavaScript 타입으로 변환.
- **Decimal 처리**: 데이터베이스의 Decimal 타입이 문자열로 반환되는 경우 적절한 변환 로직 적용.
- **JSON 배열 처리**: 데이터베이스의 JSON 컬럼을 적절한 타입으로 변환.
- **Primary Key Transformer**: ORM의 Primary Key 생성 방식에 제약이 있는 경우 대안 사용.
- **트랜잭션 관리**: 선언적 트랜잭션 관리 방식을 사용하여 코드 가독성 향상.
- **Pessimistic Lock**: 동시성 제어가 필요한 경우 적절한 락 전략 사용 (트랜잭션 내에서만 동작).
- **인덱스 설계**:
  - FK 컬럼에는 반드시 인덱스가 필요하다 (FK 생성 전에 인덱스 생성).
  - 복합 인덱스는 Leftmost Prefix Rule, 범위 조건, ORDER BY 최적화를 고려하여 설계.
  - 데이터 cardinality를 고려하여 인덱스 선택.
- **마이그레이션 순서**: 인덱스는 FK 생성 전에 생성하고, FK 삭제 전에 인덱스를 삭제한다.
- **기존 마이그레이션 수정 금지**: 기존 마이그레이션 파일은 수정하지 않고, 새 마이그레이션 파일을 생성하여 변경사항 반영.
- **Entity와 마이그레이션 일치성**:
  - Entity의 컬럼명과 마이그레이션의 컬럼명이 일치해야 한다 (네이밍 전략 적용 고려).
  - Entity와 마이그레이션의 nullable 속성, 타입, 길이 등이 일치해야 한다.
- **인덱스 이름 명시**:
  - 모든 인덱스에 명시적인 이름을 지정한다.
  - 인덱스 이름은 일관된 네이밍 컨벤션을 따른다.
  - 마이그레이션 파일의 인덱스 이름과 Entity의 인덱스 이름이 일치해야 한다.
- **외래키 이름 명시**:
  - 모든 외래키에 명시적인 이름을 지정한다.
  - 외래키 이름은 일관된 네이밍 컨벤션을 따른다.
  - 마이그레이션 파일의 외래키 이름과 Entity의 외래키 이름이 일치해야 한다.
- **Unique 제약조건**: 데이터베이스 호환성을 고려하여 적절한 방법으로 Unique 제약조건 생성.
- **외래키 onDelete 옵션**: 마이그레이션 파일에서 외래키 생성 시 onDelete 옵션 사용에 주의.
- **Datetime 컬럼 정밀도**:
  - datetime 컬럼의 정밀도를 일관되게 설정.
  - default 값과 onUpdate 값을 일관되게 설정.
  - Entity의 날짜 컬럼 데코레이터에도 타입을 명시.

### 예외 처리 규칙

- **모듈별 예외 클래스**: 각 모듈의 `exceptions` 폴더에 의미에 맞는 예외 클래스 정의.
- **Base Exception**: 모든 커스텀 예외는 기본 예외 클래스를 상속받아 구현.
- **HTTP 상태 코드**: 예외 클래스에서 적절한 HTTP 상태 코드 반환 (4xx: 클라이언트 오류, 5xx: 서버 오류).
- **구체적인 예외 메시지**: 예외 메시지는 사용자에게 명확하고 구체적인 정보를 제공.
- **프레임워크 기본 예외 사용 금지**: 프레임워크 기본 예외 대신 커스텀 예외 클래스 사용.

### DTO 및 API 규칙

- **폴더 구조**: DTO는 `request`와 `response` 폴더로 분리하여 구조화.
- **DTO 변환**: 엔티티를 DTO로 변환할 때 적절한 변환 유틸리티 사용 (불필요한 검증 로직 제거).
- **타입 안정성**: DTO에서 타입 변환은 엔티티 레벨의 transformer에서 처리 (DTO 레벨에서의 명시적 변환 최소화).

### 테스트 규칙

- 새 코드에는 새 테스트를 추가한다; 버그 수정에는 회귀 테스트를 반드시 포함한다(먼저 실패하도록 작성).
- 테스트는 결정적이고 독립적이어야 하며, 외부 시스템은 가짜/계약(컨트랙트) 테스트로 대체한다.
- E2E 테스트에는 ≥1개의 성공 경로와 ≥1개의 실패 경로를 포함한다.
- 동시성/락/재시도에서 비롯될 위험(중복, 데드락 등)을 선제적으로 평가한다.
- **E2E 테스트**: 격리된 데이터베이스 환경에서 실행 (예: Testcontainers 사용).
- **테스트 헬퍼**: 공통 테스트 헬퍼 함수는 별도 파일에 정의하여 재사용.
- **서비스 코드 수정 전 테스트 코드 수정**: 서비스 코드를 수정하기 전에 테스트 코드를 먼저 수정한다 (테스트가 실패하는 경우에만 서비스 코드 수정).
- **테스트 실행 최적화**: 테스트 프레임워크 설정에서 동시 실행 수를 제한하여 CPU 부하를 방지한다.
- **무거운 테스트 금지**: 확률 체크를 위해 대량의 비동기 작업을 동시에 실행하는 테스트는 작성하지 않는다.
- **랜덤 실패율 처리**: 랜덤 실패율이 있는 외부 의존성의 경우, E2E 테스트에서 재시도 로직을 추가한다.
- **상태 전환 테스트**: 상태 머신이 있는 경우 모든 상태 전환 경로를 고려하여 테스트를 작성한다.
- **테스트 코드 정리**: 불필요한 빈 줄, 주석, 중복 코드를 제거하여 테스트 코드를 깔끔하게 유지한다.
- **테스트 모킹 규칙**:
  - 모킹 프레임워크의 호이스팅 동작을 이해하고 올바르게 사용한다.
  - 모킹 코드는 각 테스트 파일에서 직접 작성한다 (공통 헬퍼 함수를 사용하지 않음).
  - 단위 테스트에서는 외부 의존성을 모킹하고, 실제 통합은 E2E 테스트에서만 수행한다.
- **Import 순서**: 린터가 import 순서를 체크하는 경우 올바른 순서로 작성한다 (외부 라이브러리 → 내부 모듈 순서).
- **E2E 테스트 타입 안전성**:
  - HTTP 테스트 라이브러리는 일관된 import 방식을 사용한다.
  - 애플리케이션 타입은 제네릭으로 명시하여 타입 안정성 보장.
  - 응답 타입은 인터페이스로 정의하고 타입 가드를 사용하여 검증한다.
  - 타입 가드 함수는 런타임 검증을 수행하며, 타입 단언 없이 안전하게 속성에 접근할 수 있도록 한다.

## 작업 규칙 (Work Rules)

### 커밋 규칙

- **모듈별 커밋**: 커밋은 논리적 단위(모듈, 기능 등)별로 분리한다.
- **작은 단위**: 각 커밋은 하나의 논리적 변경사항만 포함한다.
- **의미 있는 커밋 메시지**: 커밋 메시지는 변경사항을 명확히 설명한다.

### 작업 검증 규칙

각 작업 완료 후 다음 검증 단계를 수행:

1. **코드 검토**: 관련 파일 전체 읽기 및 검토.
2. **빌드 확인**: 빌드 명령어 실행하여 빌드 성공 확인.
3. **린트 확인**: 린트 명령어 실행하여 린트 오류 없음 확인 (빌드 전에 반드시 수행).
4. **타입 체크**: 빌드 과정에서 자동 수행되지만, 명시적으로 확인.
5. **테스트 실행**: 관련 단위 테스트 및 E2E 테스트 실행.
6. **문제 없을 때만 커밋**: 모든 검증이 통과한 후에만 커밋 발행.

### 작업 순서 규칙

- **파일 읽기 우선**: 코드 변경 전에 관련 파일을 처음부터 끝까지 읽는다.
- **테스트 우선**: 서비스 코드를 수정하기 전에 테스트 코드를 먼저 수정한다.
- **작은 단위 작업**: 큰 작업은 작은 단위로 나누어 순차적으로 진행한다.
- **검증 후 진행**: 각 단계마다 검증을 수행하고 문제가 없을 때만 다음 단계로 진행한다.

### 빌드 스크립트 규칙

- **스크립트 공유**: 유사한 스크립트는 공통 스크립트를 재사용하여 중복 제거.
- **스크립트 파라미터화**: 스크립트는 파라미터를 받아서 경로나 옵션을 지정할 수 있도록 한다.
- **스크립트 파일 금지**: 별도의 shell script 파일 추가보다는 프로젝트 설정 파일의 scripts 섹션에서 직접 처리.
